# 类加载过程
class 文件需要加载到虚拟机中才能够使用和运行，那么虚拟机是如何加载这些 class 文件呢？

系统加载 class 类型的文件需要三步，**加载 - 连接 - 初始化**。其中连接中又有三步，**验证 - 准备 - 解析**。

## 加载

类加载过程的第一步，主要完成以下三件事：

+ 通过全类名获取定义此类的二进制字节流
+ 将字节流所代表的静态存储结构转换为方法区运行时数据结构
+ 在内存中生成一个代表该类的 class 对象，作为方法区这些数据的访问入口

.....数据类型不通过类加载器创建，它由 Java 虚拟机直接创建。

## 验证

![验证](https://i.imgur.com/wKks535.png)

## 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的一个阶段，这些内存将在方法区分配。

注意：

1. 内存分配只是包括类变量，不包括实例变量，实例变量会在对象实例化的时候随着对象一起分配在 Java 堆中。
2. 设置变量初始值是给变量赋**零值**。栗子（略略略）：public static int value=1;那么在准备阶段value的值是0,而不是1(在初始化阶段把值复制过来)。特殊情况：public static **final** int value = 111;那么准备阶段 value 就是111了。

基本数据的零值：

![基本数据类型的零值](https://i.imgur.com/ixpAIrz.png)

## 解析

解析阶段是虚拟机将常量池中的符号引用直接替换成直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行的。

### 符号引用 & 直接引用

符号引用就是一组符号来描述目标，可以是任何字面量。

直接引用是直接指向目标的指针、相对偏移量或者间接定位到目标的句柄。

在程序实际运行时，只有符号引用是不够用的。栗子（0哈哈0）：在程序执行方法时，系统需要明确知道方法所在的位置。 Java 虚拟机为每个类提供一个	所有方法的表。当需要调用一个类的方法时，只要知道这个方法在方法表中偏移量就可以

## 初始化

初始化是类加载的最后一步，也是真正执行类定义的 Java 程序代码（字节码），是执行类构造器 `<clinit>()` 方法的过程。

对于 `<clinit>()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。

对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：

1. 当遇上 new 、getstatic 、putstatic 或 invokestatic 这4条指令代码时。
2. 使用 java.lang.reflect 包的方法对类进行反射调用时，如果没有初始化，则触发进行初始化。
3. 初始化一个类，如果父类还没有初始化，则先触发父类初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类（包含 main 方法的那个类），虚拟机会对这个类先触发初始化。
5. 当使用 JDK1.7 的动态语言时,如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个句柄没有进行初始化时，则需要触发初始化方法。
 


 
