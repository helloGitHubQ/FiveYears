<!-- TOC -->
- [Map类集合](#Map类集合)
	- [红黑树](#红黑树)
	- [TreeMap](#TreeMap)
	- [HashMap](#HashMap)
	- [ConcurrentHashMap](#ConcurrentHashMap)
# Map类集合

[map关系图片]

## 红黑树
- 树(Tree)

树是一种常用的数据结构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的这些节点中。

最顶层只有一个节点，称为**根节点**。

一个节点下方没有任何分叉的话，称为**叶子节点**。

从某节点出发，到叶子节点为止，最长简单路径上边的条数，称为**该节点的高度**。

从根节点出发，到某节点边的条数，称为**该节点的深度**。

    树结构的特点如下：
		1.一个节点，即只有根节点也可以是一个树
		2.其中任何一个节点与下面所有的节点构成的树称为子树
		3.根节点没有父节点，而叶子节点没有字节点
		4.除根节点外，任何节点有且仅有一个父节点
		5.任何节点可以有 0~n 个子节点

至多有两个子节点的树称为二叉树。二叉树是经典的问题拆解算法，二叉树是近似于二分法的一种数据结构实现。在二叉树的世界中，最为重要的概念是平衡二叉树、二叉查找树、红黑树。

- 平衡二叉树

		平衡二叉树的性质如下：
			1.树的左右高度差不能超过1
			2.任何往下递归的左子树和右子树，必须符合第一条性质
			3.没有任何节点的空树或只有根节点的树也是平衡二叉树

- 二叉查找树

二叉查找树又称二叉搜索树，即Binary Search Tree，其中Search也可以替换为 Sort ，所以也称为二叉排序树。Java中集合的最终目的就是加工数据，二叉查找树也是如此。

二叉查找树额外增加了如下要求：对于任意节点来说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的往左边走，大于节点值的往右边走，直到找到目标数据或者达到叶子节点还未找到。

	遍历所有节点的常用方式有三种：**前序遍历、中序遍历、后序遍历**。它们三者的规律如下：
		1.在任何递归子树中，左节点一定在右节点之前遍历
		2.前序、中序、后序，仅指根节点在遍历时的位置顺序

前序遍历的顺序为根节点、左节点、右节点；中序遍历的顺序为左节点、根节点、右节点；而后序遍历的顺序为左节点、右节点、根节点。

二叉查找树由于随着数据的不断地增加或删除容易平衡，为了保持二叉树重要的平衡性，有很多算法的实现，如AVL树、红黑树、SBT、Treap等。

- AVL树

可以使二叉树的使用效率最大化。AVL树是一种平衡二叉查找树，增加和删除节点后通过属性旋转重新达到平衡。**右旋**是以某节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称**顺时针旋转**；同理，**左旋**是以某个节点为中心，将它沉入当前左子节点的位置，而让当前右子节点作为新树的根节点，也称为**逆时针旋转**。AVL树就是通过不断旋转来达到树平衡的。

- 红黑树

主要特征是在每个节点上增加一个属性来表示节点的颜色，可以是红色也可以是黑色。红黑树和AVL树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自身平衡的，从而获得较高的查找性能。与AVL树相比，红黑树并不追求所有递归子树的高度差不超过1，而是保证从根节点到叶子节点的最长路劲不超过最短路径的2倍，所以它的最坏运行时间也是O(log n)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除操作后的自平衡调整。

	红黑树本质上还是二叉查找树，它额外引入了5个约束条件：
		1.节点只能是红色或黑色
		2.根节点必须是黑色
		3.所有NIL节点都是黑色的。NIL，即叶子节点下挂的两个虚节点。
		4.一条路径上不能出现相邻的两个红色节点
		5.在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点。

"有红必有黑，红红不相连"。如果一个树的左子节点或右子节点不存在，则均认定为黑色。红黑树的任何旋转在3次之内均可完成。

- 红黑树与AVL树的比较

面对频繁的插入和删除，红黑树更为合适。面对低频的修改、大量查询，AVL树更为合适。
## TreeMap
[.....]
## HashMap
除局部方法或绝对线程安全的情形外，优先推荐使用 ConcurrentHashMap。两者相差无几，后者是线程安全的。

HashMap 的死链问题及扩容数据丢失问题是慎用 HashMap 的两个重要原因。
## ConcurrentHashMap
第一次了解，第一次使用！！！

JDK8 对 ConcurrentHashMap 进行了脱胎换骨式的改造，使用了大量的 lock-free 技术来减轻因锁的竞争而对性能造成的影响。是学习并发编程的一个绝佳示例，此类超过 6300 行代码，涉及到 volatitle、CAS、锁、链表、红黑树等众多知识点。

JDK8 之前采用的是分段锁的设计理念。分段锁是由内部类 Segment 实现的，它继承于 ReentranLock，用于管理它的辖区的各个 HashEntry。 ConcurrentHashMap 被 Segement 分成了很多小区，Segement 就相当于小区保安，HashEntry 列表相当于小区业主，小区保安采用加锁的方式，保证每个 Segment 内都不发生冲突。