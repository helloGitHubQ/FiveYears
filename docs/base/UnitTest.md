<!-- TOC -->

- [单元测试](#单元测试)
  - [单元测试的基本原则](#单元测试的基本原则)
  - [单元测试覆盖率](#单元测试覆盖率)
  - [单元测试编写](#单元测试编写)
    - [JUnit单元测试框架](#JUnit单元测试框架)
    - [命名](#命名)
    - [断言与假设](#断言与假设)
  - [注意事项](#注意事项)

# 单元测试

*祸乱始于生疏，单元测试前先交付。穿越暂时黑暗的时光隧道，才能迎来系统的曙光。*

​		计算机世界里的软件产品通常是由模块组合而成，模块又可以分为诸多子模块。比如淘宝系统由搜索模块、商品模块、交易模块等组成，而交易模块又分成下单模块、支付模块、发货模块等子模块，如此细分下去，最终的子模块是由不可再分的程序单元组成。对于这些程序单元的测试，即称为单元测试（Unit Testing）。单元的粒度要根据实际情况判断，可能是类、方法等，在面向对象编程中，通常认为最小单元就是方法。

​		单元测试的目的是在集成测试和功能测试之前对软件中的可测试单元进行逐一检查和验证。单元测试是程序功能的基本保障，是软件产品上线之前非常重要的一环。

​		虽然单元测试的概念众所周知，但是能够深入理解的人却屈指可数，精于单元测试之道的工程师更是凤毛麟角。其实单元是一件有情怀、有技术涵养、有远长收益的工作；它是确保软件质量和效率的重要手段之一。

**单元测试的好处**：

- 提升软件质量

  优质的单元测试可以保障开发质量和程序的鲁棒性。

  越早发现的缺陷，其修复成本越低。

- 促进代码优化

  单元测试是由开发工程师编写和维护的，这会促使开发工程师不断重新审视自己的代码，白盒的去思考代码逻辑，更好地对代码进行设计，甚至想法设法的优化测试用例的执行效率。这个过程会促使我们不断地优化自己的代码，有时候这种优化的冲动是潜意识的。

- 提升研发效率

  编写单元测试表面上是占用了项目研发时间，但磨刀不误砍柴工，在后续的联调集成、回归测试阶段，单元测试覆盖率高的代码通常缺陷少，问题易修复，有助于提升项目的整体研发效率。

- 增加重构自信

  代码重构往往是牵一发而动全身的。当修改底层数据结构时，上层服务经常受到影响、有时候只是简单地修改一个字段名称，就会引发一系列错误。但是在单元测试保障的前提下，重构代码时我们会很自然地多一分勇气，看到单元测试 100% 执行通过那刹那充满自信和成就感。

## 单元测试的基本原则

- 宏观上，单元测试要符合 AIR 原则；
- 微观上，单元测试的代码层面要符合 BCDE 原则。

AIR 即空气，单元测试亦是如此。当业务代码在线上运行的时候，可能感觉不到测试用例的存在和价值。但是在代码质量的保障上，却是非常关键的。新增代码应该同步增加测试用例，修改代码逻辑的同时也应该同步保证测试用例成功执行。

AIR 原则具体包括：

- A：Automatic（自动化）
- I：Independent （独立性）
- R ：Repeatable （可重复）

单元测试应该是全自动执行的。测试用例通常会被频繁地触发执行，执行过程必须完全自动化才有意义。如果单元测试需要人工介入检查，那么它一定是不合格的。单元测试中不允许使用 System.out 来进行人工校验，而必须使用**断言**来验证。

为了保证单元测试稳定可靠且便于维护，需要保证其独立性。用例之间不允许互相调用，也不允许出现执行次序的先后依赖。

单元测试是可以重复执行的。不能受外界环境的影响。比如，单元测试通常会被放到持续集成中，每次有代码提交时单元测试都会被触发执行。如果单元测试对外部环境（网络、服务、中间件等）有依赖，则很容易导致持续集成机制的不可用。

编写单元测试时要保证测试粒度足够小，这样有助于精确定位问题，单元测试用例默认是方法级别的。单元测试不负责跨类或者跨系统的交互逻辑，那是集成测试需要覆盖的范围。编写单元测试用例时，为了保证被测模块的交付质量，需要符合 BCDE 原则。

- B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
- C：correct ，正确的输入，并得到预期的结果。
- D：Design，与设计文档相结合，来编写测试用例
- E：Error，单元测试的目的是证明程序有错，而不是无错。为了发现代码中潜在的错误，我们需要编写测试用例时有一些强制的错误输入（如非法数据、异常流程、非业务允许输入等）来得到预期的错误结果。

由于单元测试知识系统集成测试前的小模块测试，有些因素往往不具备的，因此需要进行 Mock,例如：

1）<u>功能因素</u>。比如被测方法内部调用的功能不可用

2）<u>时间因素</u>。比如双十一还没来，与此时间相关的功能点

3）<u>环境因素</u>。政策环境，如支付宝政策类新功能；多端环境，如 PC、手机等

4）<u>数据因素</u>。线下数据规模小，难以覆盖各种线上真实场景

5）<u>其他因素</u>。为了简化测试编写，开发者也可以将一些负责的依赖采用 Mock 方式实现。

最简单的 Mock 方式硬编码，更为优雅的方式是使用配置文件，最佳的使用方式是 使用相应的 Mock 框架，例如 JMockit、EasyMock、JMock等。Mock 的本质是让我们写出更加稳定的测试用例，隔离上述因素对单元测试的影响，使结果变得可预测，做到真正的 “单元” 测试。

## 单元测试覆盖率

单元测试是一种白盒测试，测试者根据程序的内部结构来实现测试代码。单元测试覆盖率是指业务代码被单元测试的比例和程度，它是衡量单元测试好坏的一个重要指标，各类覆盖率指标从粗到细、从弱到强如下：

- 粗粒度的覆盖

  粗粒度覆盖分两种类覆盖和方法覆盖。

  类覆盖：指类中有方法或者变量被测试用例调用或者执行到，那么就说这个类被测试覆盖了。

  方法覆盖：同理，只要在测试用例执行过程中，某个方法被调用了，则无论执行了该方法中的多少行代码，都可以认为该方法被测试覆盖了。

  从实际测试场景来看，无论是以类覆盖率还是方法覆盖率来衡量测试覆盖范围，其粗粒度都太大了。

  

- 细粒度的覆盖

  - 行覆盖（Line Coverage）

    行覆盖也叫语句覆盖，用来度量可执行的语句是否被执行到。行覆盖率的计算公式的分子是执行到的语句数，分母是总的可执行语句行数

  - 分支覆盖（Branch Coverage）

    分支覆盖也叫判定覆盖，用来度量程序中每一个判定分支是否被执行到。分支覆盖率的计算公式中的分子是代码中被执行到的分支数，分母是代码中所有分支的总数。

  - 条件判定覆盖（Condition Decision Coverage）

    条件判定覆盖要求设计足够的测试用例，能够让判定中每个条件的所有可能情况至少被执行一次，同时每个判定本身的所有可能结果也至少执行一次。

  - 条件组合覆盖（Multiple Condition Coverage）

    条件组合覆盖是指判定中所有条件的各种组合情况都出现至少一次。

  - 路径覆盖（Path Coverage）

    路径覆盖要求能够测试到程序中所有可能的路径。

  

  ## 单元测试编写

  单元测试编写是开发工程师的日常工作之一，利用好各种测试框架并掌握好单元测试编写技巧，往往可以到达事半功倍的效果。

  ### JUnit单元测试框架

  Java 语言的单元测试框架相对统一，JUnit 和 TestNG 几乎始终处于市场前两位。

  JUnit 于 2017 年 9 月正式发布了 5.0 稳定版本。

  JUnit5 对 JDK8 及以上版本有了更好的支持（如增加了对  Lambda 表达式的支持），并且加入了更多测试形式，如重复测试、参数化测试等。

  JUnit5.x 由以下三个模块组成 ：

  - JUnit Platform：用于 JVM 上启动测试框架，统一命令行、Gradle 和 Maven 等方式执行测试入口。
  - JUnit Hupiter：包含 JUnit5.x 全新的编程模型和扩展机制
  - JUnit Vintage：用于在新的框架中兼容运行 JUnit3.x 和 JUnit4.x 的测试用例



| 注解               | 释义                                                         |
| :----------------- | :----------------------------------------------------------- |
| @Test              | 注明这个方法是测试方法，JUnit 框架会在测试阶段自动找出所有使用该注解标明的测试方法并运行。JUnit5版本中，取消了注解的 timeout 参数的支持 |
| @TestFactory       | 注明一个方法是基于数据驱动的动态测试数据源                   |
| @ParameterizedTest | 注明一个方法是测试方法。而且可以让一个测试方法使用不同的入参运行多次。 |
| @RepeatedTest      | 让测试方式自定义重复运行次数                                 |
| @BeforeEach        | 与 JUnit4 中的 @Before 类似，可以在每一个测试方法运行前，都运行一个指定的方法。JUnit5 中，额外支持运行 @ParameterizedTest 和 @RepeatedTest 注解的方法 |
| @AfterEach         | 与 JUnit4 中的 @After 类似，可以在每一个测试方法运行后，都运行一个指定的方法。JUnit5 中，额外支持运行 @ParameterizedTest 和 @RepeatedTest 注解的方法 |
| @BeforeAll         | 与 JUnit4 中的 @BeforeClass 类似，可以在每一个测试类运行前，都运行一个指定的方法 |
| @AfterAll          | 与 JUnit4 中的 @AfterClass 类似，可以在每一个测试类运行后，都运行一个指定的方法 |
| @Disabled          | 与 JUnit4 中的 @Ignore 类似，注明一个测试的类或者方法不再运行 |
| @Nested            | 为测试添加嵌套层级，以便组织用例结构                         |
| @Tag               | 为测试或方法添加标签，以便有选择性地执行                     |

### 命名

通常来说，单元测试的定义与被测试类一一对应，放置于被测试类相同的包路径下，并以测试类的名称加上 Test 命名。

单元测试代码必须写在工程目录 src/test/java 下，不允许写在业务代码目录下，因为主流的 Java 测试框架如 JUnit 、TestNG 测试代码都是默认放在 src/test/java 下的，测试资源文件则放在 src/test/resources 下，这样有利于代码目录标准化。统一约定代码存放结构带来的好处是，当修改别人的工程时，也能有一种修改自己工程的感觉，能清楚知道哪些代码放在什么目录下。

### 断言与假设

当定义好了需要运行的测试方法后，下一步则是关注测试方法的细节处理，这就离不开断言（assert ）和假设（assume）：断言封装好了常用的判断逻辑，当不满足条件时，该测试用例会被认定为测试失败；假设与断言类似，只不过当条件不满足时，测试会直接退出而不是认定为测试失败，最终记录的状态是跳过。断言和假设是单元测试中最重要的部分，各种单元测试框架均提供了丰富的方法。

JUnit5.x 中常用的断言被封装在 org.junit.jupiter.api.Assertions 类中，均为静态方法。

| 方法                                    | 释义                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| fail                                    | 断言测试失败                                                 |
| assertTure/assertFalse                  | 断言条件为真或者假                                           |
| assertNull/assertNotNull                | 断言结果值为 null 或非 null                                  |
| assertEquals/assertNotEquals            | 断言指定两个值相等或者不相等，对于基本数据类型，使用值比较；对于对象，使用 equals 方法比较 |
| assertArrayEquals                       | 断言数组元素全部相等                                         |
| assertSame/assertNotSame                | 断音指定两个对象是否为同一个对象                             |
| assertThrows/assertDoesNotThrow         | 断言是否抛出一个特定类型的异常                               |
| assertTimeout/assertTimeoutPreemptively | 断言执行是否超时，区别在于测试程序是否在同一线程内执行       |
| assertIterableEquals                    | 断言迭代器中的元素全部相等                                   |
| assertLinesMatch                        | 断言字符串列表元素全部正则匹配                               |
| assertAll                               | 断言多个条件同时满足                                         |

相对于断言，假设提供的静态方法更为简单，被封装在 org.junit.jupiter.api.Assumptions 类中，同样为静态方法。

| 方法                        | 释义                                                 |
| --------------------------- | ---------------------------------------------------- |
| assumeTure<br />assumeFalse | 先判断给定的条件为真或假，再决定是否继续接下来的测试 |

相对于假设，断言更重要。

```
对于断言的选择，优先采用更精确的断言，因为它们通常提供更友好的结果输出格式（包括预期值和实际值），例如 assertEqual（100，result）语句优于 assertTrue（100 == result）语句。

对于非相等情况的判定，比如大于、小于或者更复杂的情况，则可以使用 assertTue 或 assertFalse 表达，比如 assertTrue（result > 0）。

对于特别复杂的条件判定，直接使用任何一种断言方法都不容易表达时，则可以使用 Java 语句自行构造条件，然后在不符合预期的情况下直接使用 fail 断言方法将测试标记为失败。

对于所有两参数的断言方法，比如 assertEquals 或 assertSame ，第一个参数是预期的结果值，第二个参数才是实际的结果值。
```

assertTimeout 和 assertTimeoutPreemptively 断言的差异在于，前者会在操作超时时继续执行，并在最终的测试报告中记录操作的实际执行时间；后者在到达指定时间后立刻结束，在最终报告中只体现出操作超时，并不包含实际执行耗时。

- AssetJ：最大的特点是流式断言（Fluent Assertions）与 Builder Chain 模式或 Java 8 的 stream&filter 写法类似。

  它允许一个目标对象通过各种 Fluent Assert API 的连接判断，进行多次断言，并且对 IDE 更友好。但是 AssertJ 的 assertThat 的处理方法和之前有些不同，它利用 Java 的泛型，同时增加了目标类型对应的 XxxxAssert 类，签名为  "public static AbstractCharSequenceAssert<?,String> assertThat(Stringactual)" ，而 Junit 中的 "public static void assertThat() " 是 void 返回，其中，AbstractCharSequenceAssert 是针对 String 对象的，这样不同的类型有不同的断言方法，如 String 和 Date 就有不一样的断言方法。

  ​         <u>如果是我们自定义的 JavaBean 该如何判断，例如我们常见的 Account 对象，如何传给 assertThat ，然后进行断言判断？</u>

  AssertJ 通过 AssertJ assertions generator 来生成对应的 XxxxAssert 类，然后辅助我们对模板 JavaBean 对象进行断言 API 判断。 AssertJ assertions generator 有对应的 Maven 和 Gradle Plugin ,生成这样的代码很容易，所以很容易实现对自定义 JavaBean 对象的判断需求。此外，AssertJ 还添加了常用的扩展，如 DB assertions，Guava assertions 等，以方便我们使用。例如，典型的 DB assertions ,无论你使用哪种框架，在执行完数据库操作后，就可以使用 DB assertions 对数据库中的数据进行断言，非常适合单元测试。

---

## 注意事项

使用 @Test 注解运行的方法必须遵循的4个原则：

1. 方法必须是公共的(public)
2. 方法必须是非静态的
3. 方法必须是无返回值的
4. 方法必须是无参的





