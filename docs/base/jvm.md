# JVM

### 5/26/2019 3:53:24 PM 

- java内存参数	

有两种模式Server（启动慢，运行快）和Client（启动快，运行慢）。

### 5/27/2019 9:38:28 PM 

堆  栈  方法区

## Java内存空间

![jdk1.6](https://i.imgur.com/jHqpbye.png)

&

![jdk1.8](https://i.imgur.com/005yIoT.png)


## JVM垃圾回收

### JVM内存分配和回收
---

Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时最核心的功能是	堆 内存中对象的分配和回收。

![Java堆](https://i.imgur.com/Eorx0Ob.png)

堆内存常见的分配策略：

![分配策略](https://i.imgur.com/gWtjL5k.png)
1 . 对象优先在 eden 区分配

2 . 大对象直接进入老年代

为了避免为大对象分配内存的时候由于分配担保机制带来的复制而降低效率

3 . 长期存活的对象将进入老年代

虚拟机给每个对象一个对象年龄计数器（Age）。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

4 .  动态对象年龄判断

虚拟并不是永远要求对象年龄必须到达某个值才进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于该年龄的就直接进入老年代。

### 对象死亡
---

![对象死亡](https://i.imgur.com/CLobQaA.png)

1 . 引用计数法：

就是有引用的话计数器加1，当引用失效的时候计数器减1.所以计数器为0的对象就是不会再被用到的对象。

2 . 可达性分析算法：

![可达性分析算法](https://i.imgur.com/7ChhAIr.png)

引用：

- 强引用：就像生活中必需品一样，所以当内存空间不足，Java虚拟机宁愿抛出 OutOfMemoryError 错误，也不愿去回收。

- 软引用：当内存空间不足的话，就会过来回收它。只要垃圾回收器没有回收它，它就可以继续被程序引用。软引用可以用来实现内存敏感的高速缓存。

- 弱引用：垃圾收集器扫描它所管辖的范围中，如果发现有弱引用对象的话就会直接被回收。不过，垃圾收集器是优先级很低的线程，因此不一定很快就会发现那些弱引用的对象。

软引用 & 弱引用的区别：就是弱引用的生命周期更短。

- 虚引用：就是摆设引用。就跟没有引用一样，任何时候都可能被垃圾回收。
**虚引用主要用来跟踪对象被垃圾回收的活动。**

虚引用与软引用&弱引用的区别：

注意：**程序设计中很少使用都虚引用和弱引用。使用最多的是软引用，软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题。**

3 . 废弃常量

4 . 无用的类

### 垃圾收集算法
---

1. 标记 - 清除算法：效率问题 & 空间问题

![标记清除算法](https://i.imgur.com/opxRnwD.png)

2. 复制算法：
![复制算法](https://i.imgur.com/xrp4MHY.png)
3. 标记 - 整理算法：
![标记整理算法](https://i.imgur.com/liYTL8m.png)
4. 分代收集算法：主流收集器采用的回收算法。

分代其实就很明显了，一般就是将java堆分为新生代和老年代。

### 垃圾收集器
---
根据自己的场景选择适合自己的垃圾收集器。

![垃圾收集器](https://i.imgur.com/jfXMyby.png)

1. Serial 收集器：单线程收集器（最古老的）

2. ParNew 收集器：是多线程版本的 Serial 收集器

3. Parallel Scavenge 收集器：**关注点是吞吐量（高效率利用CPU）**

4. Serial Old 收集器

5. Parallel Old 收集器

6. CMS 收集器:"标记-清除" 算法实现

7. G1 收集器:**一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**
