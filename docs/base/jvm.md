# JVM

### 5/26/2019 3:53:24 PM 

- java内存参数	

有两种模式Server（启动慢，运行快）和Client（启动快，运行慢）。

### 5/27/2019 9:38:28 PM 

堆  栈  方法区

## Java内存空间

![jdk1.6](https://i.imgur.com/jHqpbye.png)

&

![jdk1.8](https://i.imgur.com/005yIoT.png)


## JVM垃圾回收

### JVM内存分配和回收
---

Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时最核心的功能是	堆 内存中对象的分配和回收。

![Java堆](https://i.imgur.com/Eorx0Ob.png)

堆内存常见的分配策略：

![分配策略](https://i.imgur.com/gWtjL5k.png)

1 . 对象优先在 eden 区分配

2 . 大对象直接进入老年代

为了避免为大对象分配内存的时候由于分配担保机制带来的复制而降低效率

3 . 长期存活的对象将进入老年代

虚拟机给每个对象一个对象年龄计数器（Age）。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

4 .  动态对象年龄判断

虚拟并不是永远要求对象年龄必须到达某个值才进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于该年龄的就直接进入老年代。

### 对象死亡
---

![对象死亡](https://i.imgur.com/CLobQaA.png)

1 . 引用计数法：

就是有引用的话计数器加1，当引用失效的时候计数器减1.所以计数器为0的对象就是不会再被用到的对象。

2 . 可达性分析算法：

![可达性分析算法](https://i.imgur.com/7ChhAIr.png)

引用：

- 强引用：就像生活中必需品一样，所以当内存空间不足，Java虚拟机宁愿抛出 OutOfMemoryError 错误，也不愿去回收。

- 软引用：当内存空间不足的话，就会过来回收它。只要垃圾回收器没有回收它，它就可以继续被程序引用。软引用可以用来实现内存敏感的高速缓存。

- 弱引用：垃圾收集器扫描它所管辖的范围中，如果发现有弱引用对象的话就会直接被回收。不过，垃圾收集器是优先级很低的线程，因此不一定很快就会发现那些弱引用的对象。

软引用 & 弱引用的区别：就是弱引用的生命周期更短。

- 虚引用：就是摆设引用。就跟没有引用一样，任何时候都可能被垃圾回收。
**虚引用主要用来跟踪对象被垃圾回收的活动。**

虚引用与软引用&弱引用的区别：

注意：**程序设计中很少使用都虚引用和弱引用。使用最多的是软引用，软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题。**

3 . 废弃常量

4 . 无用的类

### 垃圾收集算法
---

1. 标记 - 清除算法：效率问题 & 空间问题

![标记清除算法](https://i.imgur.com/opxRnwD.png)

2. 复制算法：

![复制算法](https://i.imgur.com/xrp4MHY.png)

3. 标记 - 整理算法：

![标记整理算法](https://i.imgur.com/liYTL8m.png)

4. 分代收集算法：主流收集器采用的回收算法。

分代其实就很明显了，一般就是将java堆分为新生代和老年代。

### 垃圾收集器
---
根据自己的场景选择适合自己的垃圾收集器。

![垃圾收集器](https://i.imgur.com/jfXMyby.png)

1. Serial 收集器：单线程收集器（最古老的）

2. ParNew 收集器：是多线程版本的 Serial 收集器

3. Parallel Scavenge 收集器：**关注点是吞吐量（高效率利用CPU）**

4. Serial Old 收集器

5. Parallel Old 收集器

6. CMS 收集器:"标记-清除" 算法实现

7. G1 收集器:**一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**


## JDK监控和故障处理工具

### JDK命令行工具
---

### 5/30/2019 10:53:57 PM 

1. jps(JVM Process Status):

查看所有 JAVA 进程的启动类，传入参数和 JVM 参数等等。

2. jstat（JVM Statistics Monitoring Tool）：

用于收集 HotSpot 虚拟机各方面的运行数据。

![jstat](https://i.imgur.com/271LEyY.png)

3. jinfo（Configuration Info for Java）：

显示虚拟机配置信息。

4. jmap（Memory Map for Java）：

生成堆转储快照。

5. jhat（JVM Heap Dump Browser ）：

用于分析 headump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看结果。

6. jstack（Stack Trace for Java）：

生成虚拟机当前时刻的线程快照。


### JDK 可视化分析工具
---

JConsole:Java 监视和管理控制台

Visual VM : 多合一故障处理工具


注：**看完还是一脸懵逼。(^_−)☆**

## 类文件结构

![](https://i.imgur.com/eEOspuh.png)

.class 文件（字节码文件）；.class文件是不用语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台的主要原因之一。

![](https://i.imgur.com/B7btXMF.png)

- 魔数：确认该文件能否被虚拟机接受的 Class 文件。

CLass 文件版本：高版本的 Java 虚拟机可以执行低版本的编辑器生成的 class 文件，但是低版本的 Java 虚拟机就不能执行高版本的编辑器生成的 class 文件。实际开发中的 JDK 版本和生产上的 JDK 版本一致。

- 常量池：常量池计数器是从1开始的，0代表 不引用任何一个常量池项 。

开始的第一位是一个 u1 类型的标志位	 -tag 来标识常量的类型。

- 访问标识：用于识别一些类或者接口层次的访问信息。

- 当前类索引，父类索引和接口索引集合：

- 字段表集合：

- 方法表集合：

- 属性表集合：

