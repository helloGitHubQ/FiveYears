<!--TOC-->

- [树](#树)
  - [平衡二叉树](#平衡二叉树)
  - [二叉查找树](#二叉查找树)
  - [AVL树](AVL树)
  - [红黑树](#红黑树)

<!--TOC-->

# 树

​        树(Tree)是一种常用的数据结构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的这些节点中。最顶层只有一个节点，称为根节点。在分支处有一个节点，指向多个方向，如果某节点下方没有任何分叉的话，就是叶子节点。从某节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的高度；从根节点出发到某节点边的条数，称为该节点的深度。

**树结构的特点**如下：

- 一个节点，即只有根节点，也可以是一棵树
- 其中任何一个节点与下面所有节点构成的树称为子树
- 根节点没有父节点，而叶子节点没有字节点
- 除根节点外，任何节点有且仅有一个父节点
- 任何节点可以有 0 ~ n 个子节点

至多有两个节点的树称为二叉树。二分法是经典的问题拆解算法，二叉树是近似于二分法的一种数据结构实现，二叉树是高效算法现实的载体，在整个数据结构领域具有举足轻重的地位。

## 平衡二叉树

**平衡二叉树的性质**如下：

- 树的左右高度差不能超过 1
- 任何往下递归的左子树和右子树，必须符合第一条性质
- 没有任何节点的空树或只有根节点的树也是平衡二叉树

## 二叉查找树

二叉查找树又称二叉搜索树，即 Binary Search Tree，其中 Search 也可以替换为 Sort ，所以也称为二叉搜索树。Java 中集合的最终目的就是加工数据，二叉查找树也是如此。树如其名，二叉查找树非常擅长数据查找。二叉查找树额外增加了如下条件：

对于任何节点来说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的往左边走，大于节点值的往右边走，直到找到目标数据或者达到叶子节点还未找到。

遍历所有节点的常用方式有三种：前序遍历、中序遍历和后续遍历。

- 在任何递归子树中，左节点一定在右节点之前遍历
- 前序、中序、后序，仅指根节点在遍历时的位置顺序。

前序遍历的顺序是根节点、左节点、右节点；中序遍历的顺序是左节点、根节点、右节点；而后序遍历的顺序是左节点、右节点、根节点。

二叉查找树由于随着数据不断地增加或删除容易失衡，为了保持二叉树重要的平衡性，有很多算法的实现，如AVL 树、红黑树、SBT（Size Balanced Tree）、Treap（树堆）等。

## AVL树

AVL 树是一种平衡查找二叉树，增加和删除节点后通过树形旋转重新到达平衡。

右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转；同理，左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前右子节点作为新树的根节点，也称逆时针旋转。

AVL 树就是通过不断旋转来达到树平衡的。

## 红黑树

红黑树是于 1972 年发明的，当时称为对称二叉 B 树，1978 年得到优化，正式命名为红黑树。它的主要特征 是在每个节点上增加一个属性来表示节点的颜色，可以是红色也可以是黑色。

红黑树和 AVL 树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自身平衡的，从而获得较高的查找性能。与 AVL 相比，红黑树并不追求所有递归子树的高度差不超过 1 ，而是保证从根节点到叶子节点的最长路径不超过最短路径的 2 倍，所以它的最坏运行时间也是 O(log n)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除操作后的自身平衡调整。当然，红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件：

- 节点只能是红色或黑色
- 根节点必须是黑色
- 所有 NIL 节点都是黑色。NIL ：即叶子节点下面的两个虚节点
- 一条路径上不能出现相邻的两个红色节点
- 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数据的黑色节点。

**有红有黑，红红不相连**