# 数据结构 

<u>廊腰缦回，檐牙高啄。纵使相同一砖一瓦，不同雕琢设置，亦生错落有致的廊榭美景。数据结构的魅力也缘于此中道理。</u>

## 数据结构定义

数据结构是指逻辑意义上的数据组织方式及其相应的处理方式。

- 逻辑意义：

  数据结构的抽象表达非常丰富，而实际物理存储的方式相对单一。

  比如，二叉树在磁盘中的存储真的是树形排列吗？并非如此。树的存储可能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放，设想有 7 个节点的二叉树，第一个格子放在根节点，第二个格子放在左子树根节点；并且根据引用知道左叶子在后续的哪个格子里；第三个格子放右子树根节点，依次类推。此外，树的存储方式也可能基于物理上的链式存储方式。

- 数据组织方式：

  逻辑意义上的数据组织方式有很多，比如树、图、队列、哈希等。树可以是二叉树、三叉树、B+树等；图可以是有向图或无向图；队列是先进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式。

- 数据处理方式：

  在既定的数据组织方式上，以某种特定的算法实现数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性能差异

## 数据结构分类

数据结构是实现算法的基石，它是一种体现基础逻辑思维的内功心法，也是计算机从业人员能力图谱中的重要一项。如果完全不懂数据结构，很难写出优秀的代码。有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结构进行设计和评审。从直接前继和直接后继的维度来看，大致可以将数据结构分为以下四类：

- 线性结构

  0 至 1 个直接前继和直接后继。当线性结构非空时，有唯一的首元素和尾元素，除两者之外，所有的元素都有唯一的直接前继和直接后继。线性结构包括顺序表、链表、栈、队列等，其中栈和队列是访问受限的结构。

  栈是先进后出，即 Last - In ，First - Out ，简称 LIFO；

  队列是先进先出，即 First - In ，First - Out ，简称 FIFO；

- 树结构

  0 至 1 个直接前继和 0 至  n 个直接后继（n 大于或等于 2）。树是一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定和均衡，在计算机领域中得到广泛应用。

- 图结构

  0 至 n 个直接前继和直接后继（n 大于或等于 2）。图结构包括简单图、多重图、有向图和无向图等。

- 哈希结构

  没有直接前继和直接后继。哈希结构通过某种特定的哈希函数将索引与存储的值关联起来，它是一种查找效率非常高的数据结构。

```
不同的数据组织方式和处理方式带来了一个全新的问题：如何衡量数据处理的性能？
    数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的情况下，时间复杂度成为重点考量的因素。算法时间复杂度是一种衡量计算性能的指标，反映了程序执行时间随着输入规模增长而增长的量级，在很大程度上能反映出算法性能的优劣与否。而这个量级通常用于大写 O 和一个函数描述，如 O(n^3) 表示程序执行时间随输入规模呈现三次方倍的增长，这是比较差的算法实现。
    从最好到最坏的常用算法复杂度排序如下：常数级 O(1)、对数级 O(log n)、线数级 O(n)、线数对数级 O(nlog n)、平方级 O(n^2)、立方级 O(n^3)、指数级 O(2^n)。有人觉得在实际编程中没有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数据规模并不是静止不变的，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的急剧下降。
```

最后以 猜数字 为例进一步解释时间复杂度，主持人从 1~100的范围内选择任意一个数字，玩家随机猜一个数字，如果没有猜中，主持人会提示猜大了还是猜小了，继续这样的循环，直到猜对为止。显而易见，如果猜测，最多要猜 100 次，最后只用猜 1 次。经验表明，玩家总是往中间砍一段，平均猜测次数总在七八次左右。通过模拟程序运行 1 亿次，完全随机的情况下，平均猜测的次数是 7.47 次，近似二分法猜测的 5.8 次，时间复杂度为 O(log n)

## 树(Tree)

​        树是一种常用的数据结构，它是一个由有限节点组成的一个具有层次关系的集合，数据就存在树的这些节点中。最顶层只有一个节点，称为根节点。在分支处有一个节点，指向多个方向，如果某节点下方没有任何分叉的话，就是叶子节点。从某节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的高度；从根节点出发到某节点边的条数，称为该节点的深度。

**树结构的特点**如下：

- 一个节点，即只有根节点，也可以是一棵树
- 其中任何一个节点与下面所有节点构成的树称为子树
- 根节点没有父节点，而叶子节点没有字节点
- 除根节点外，任何节点有且仅有一个父节点
- 任何节点可以有 0 ~ n 个子节点

至多有两个节点的树称为二叉树。二分法是经典的问题拆解算法，二叉树是近似于二分法的一种数据结构实现，二叉树是高效算法现实的载体，在整个数据结构领域具有举足轻重的地位。

### 平衡二叉树

**平衡二叉树的性质**如下：

- 树的左右高度差不能超过 1
- 任何往下递归的左子树和右子树，必须符合第一条性质
- 没有任何节点的空树或只有根节点的树也是平衡二叉树

### 二叉查找树

二叉查找树又称二叉搜索树，即 Binary Search Tree，其中 Search 也可以替换为 Sort ，所以也称为二叉搜索树。Java 中集合的最终目的就是加工数据，二叉查找树也是如此。树如其名，二叉查找树非常擅长数据查找。二叉查找树额外增加了如下条件：

对于任何节点来说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的往左边走，大于节点值的往右边走，直到找到目标数据或者达到叶子节点还未找到。

遍历所有节点的常用方式有三种：前序遍历、中序遍历和后续遍历。

- 在任何递归子树中，左节点一定在右节点之前遍历
- 前序、中序、后序，仅指根节点在遍历时的位置顺序。

前序遍历的顺序是根节点、左节点、右节点；中序遍历的顺序是左节点、根节点、右节点；而后序遍历的顺序是左节点、右节点、根节点。

二叉查找树由于随着数据不断地增加或删除容易失衡，为了保持二叉树重要的平衡性，有很多算法的实现，如AVL 树、红黑树、SBT（Size Balanced Tree）、Treap（树堆）等。

### AVL树

AVL 树是一种平衡查找二叉树，增加和删除节点后通过树形旋转重新到达平衡。

右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转；同理，左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前右子节点作为新树的根节点，也称逆时针旋转。

AVL 树就是通过不断旋转来达到树平衡的。

### 红黑树

红黑树是于 1972 年发明的，当时称为对称二叉 B 树，1978 年得到优化，正式命名为红黑树。它的主要特征 是在每个节点上增加一个属性来表示节点的颜色，可以是红色也可以是黑色。

红黑树和 AVL 树类似，都是在进行插入和删除元素时，通过特定的旋转来保持自身平衡的，从而获得较高的查找性能。与 AVL 相比，红黑树并不追求所有递归子树的高度差不超过 1 ，而是保证从根节点到叶子节点的最长路径不超过最短路径的 2 倍，所以它的最坏运行时间也是 O(log n)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除操作后的自身平衡调整。当然，红黑树在本质上还是二叉查找树，它额外引入了 5 个约束条件：

- 节点只能是红色或黑色
- 根节点必须是黑色
- 所有 NIL 节点都是黑色。NIL ：即叶子节点下面的两个虚节点
- 一条路径上不能出现相邻的两个红色节点
- 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数据的黑色节点。

**有红有黑，红红不相连**